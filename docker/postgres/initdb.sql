create extension if not exists pgcrypto;
create extension if not exists citext;

create table public.tx_fetched (
    id integer primary key generated by default as identity,
    txtimestamp bigint not null,
    chainid bigint not null,
    blockid bigint not null,
    selector varchar(6),
    txid varchar(42) not null,
    txfrom varchar(42) not null,
    txto varchar(42),
    txvalue citext,
    txdata citext,
    rawtxbody citext
);

alter table only public.tx_fetched 
    add constraint crosschain_txid unique(chainid, txid);

create index blockid_index on public.tx_fetched using btree (blockid);

create index chainid_index on public.tx_fetched using btree (chainid);

create index txid_index on public.tx_fetched using hash (txid);

-- create table public.interaction (
--     id integer primary key generated by default as identity,
--     interaction_hash varchar(66) not null,
--     chainid bigint,
--     selector varchar(6),
--     txto varchar(42)
-- );

create table public.interaction_approve (
    id integer primary key generated by default as identity,
    interaction_hash varchar(66) not null,
    eth_address varchar(42) not null,
    message_ citext,
    signature_hex citext
);

alter table only public.interaction_approve 
    add constraint approve_pair unique(interaction_hash, eth_address);

create index interaction_hash_index on public.interaction_approve using btree(interaction_hash);

create index eth_address_index on public.interaction_approve using btree(eth_address);

create table public.interaction_map (
    id integer primary key generated by default as identity,
    eth_address varchar(42) not null,
    interaction_hash varchar(66) not null
);
